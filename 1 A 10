EX 1)
1. // Distância do sensor 2. int distancia = 0; 3.  4. // Função de leitura do sensor 5. long readUltrasonicDistance(int triggerPin, int echoPin) 6. { 7.    // Porta triggerPin em modo de saída (escrita) 8.    pinMode(triggerPin, OUTPUT);   9.    digitalWrite(triggerPin, LOW); 10.    delayMicroseconds(2); 11.    digitalWrite(triggerPin, HIGH); 12.    delayMicroseconds(10); 13.    digitalWrite(triggerPin, LOW); 14.    // Porta echoPin em modo de entrada (leitura) 15.    pinMode(echoPin, INPUT); 16.    return pulseIn(echoPin, HIGH); 17. } 18.  19. void setup() 20. { 21.    Serial.begin(9600); 22. } 23.  24. void loop() 25. { 26.    // Leitura e cálculo da distância do objeto 27.    distancia = 0.01723 * readUltrasonicDistance(4, 5); 28.    // Saída da variável no monitor serial 29.    Serial.println(distancia); 30.    // Atrase um pouco para melhorar o desempenho da simulação 31.    delay(10);  32. } 

EX 2)
33. // Distância do sensor 34. int distancia = 0; 35.  36. // Função de leitura do sensor 37. long readUltrasonicDistance(int triggerPin, int echoPin) 38. { 39.    // Porta triggerPin em modo de saída (escrita) 40.    pinMode(triggerPin, OUTPUT);   41.    digitalWrite(triggerPin, LOW); 42.    delayMicroseconds(2); 43.    digitalWrite(triggerPin, HIGH); 44.    delayMicroseconds(10); 45.    digitalWrite(triggerPin, LOW); 46.    // Porta echoPin em modo de entrada (leitura) 47.    pinMode(echoPin, INPUT); 48.    return pulseIn(echoPin, HIGH); 49. } 50.  51. void setup() 52. { 53.    pinMode(12, OUTPUT); 54.    pinMode(13, OUTPUT); 55. } 56.  57. void loop() 58. { 59.    // Leitura e cálculo da distância do objeto 60.    distancia = 0.01723 * readUltrasonicDistance(4, 5); 61.    if (distancia < 100) { 62.       digitalWrite(12, HIGH); 63.       digitalWrite(13, LOW); 64.    } else { 65.       digitalWrite(12, LOW); digitalWrite(13, HIGH); 67.    } 68.    // Atrase um pouco para melhorar o desempenho da simulação 69.    delay(10);  

EX 3)
1. // Nenhum código fonte 

EX 4) 1. // Armazena o estado do botão lido 2. int estadoBotao = 0; 3.    4. void setup()  5. { 6.    // Porta 13 (LED_BUILTIN) em modo de saída(escrita) 7.    pinMode(LED_BUILTIN, OUTPUT); 8.    // Porta 12 (Botão) em modo de entrada(leitura) 9.    pinMode(12, INPUT);  10. } 11.  12. void loop() { 13.    // Leitura do botão na porta 12 14.    estadoBotao = digitalRead(12); 15.  16.    // Liga ou desliga o LED 17.    if (estadoBotao == HIGH) { 18.       digitalWrite(LED_BUILTIN, HIGH); 19.    } else { 20.       digitalWrite(LED_BUILTIN, LOW); 21.    } 22.    // Atrase um pouco para melhorar o desempenho da simulação 23.    delay(10);  24. } 

EX 5)
1. // Armazena o estado do botão lido 2. int estadoBotao = 0; 3.  4. // Guarda o estado 5. int guardaEstado = 0; 6.    7. void setup()  8. { 9.    // Porta 12 (Botão) em modo de entrada(leitura). 10.    pinMode(12, INPUT);  11.    // Porta 13 (LED_BUILTIN) em modo de saída(escrita). 12.    pinMode(LED_BUILTIN, OUTPUT);    13. } 14.  15. void loop() { 16.    // Leitura do botão na porta 12 17.    estadoBotao = digitalRead(12); 18.    // Se estão do botão igual a HIGH acende o LED na porta 13 19.    if (estadoBotao == HIGH) { 20.       // Se o estado guardado é HIGH inverte o valor 21.       if (guardaEstado == HIGH) { 22.           guardaEstado = LOW; 23.      } else { 24.           guardaEstado = HIGH; 25.      } 26.    } 27.  28.    // Liga ou desliga o LED 29.    if (guardaEstado == HIGH) { 30.       digitalWrite(LED_BUILTIN, HIGH); 31.    } else { 32.       digitalWrite(LED_BUILTIN, LOW); 33.    } 34.    // Atrase um pouco para melhorar o desempenho da simulação 35.    delay(250); 36.}

EX 6)
1. // Armazena o estado do sensor 2. int estadoSensor = 0; 3.  4. void setup() 5. { 6.     // Porta 13 (LED_BUILTIN) em modo de entrada(leitura) 7.     pinMode(12, INPUT); 8.     // Porta 13 (LED_BUILTIN) em modo de saída(escrita) 9.     pinMode(LED_BUILTIN, OUTPUT); 10. } 11.  12. void loop() 13. { 14.     // Leitura do sensor da porta 12 15.     estadoSensor = digitalRead(12); 16.     // Se o sensor é igual a 1 17.     if (estadoSensor == HIGH) { 18.        digitalWrite(LED_BUILTIN, HIGH); 19.     } else { 20.        digitalWrite(LED_BUILTIN, LOW); 21.     } 22.     // Atrase um pouco para melhorar o desempenho da simulação 23.     delay(10);   24. } 

EX 7)
1. // Biblioteca para manipular o servo 2. #include <Servo.h> 3.  4. //Variável da posição do servo 5. int i = 0; 6.  7. //Variável do micro servo 8. Servo servo_11; 9.  10. void setup() 11. { 12.   // Conecta o micro servo na porta 11 13.   servo_11.attach(11, 500, 2500); 14. } 15.  16. void loop() 17. { 18.   // Avança de 0 graus até 90 graus 19.   for (i = 0; i <= 90; i += 1) { 20.     servo_11.write(i); 21.     delay(15); // Aguarda 15 milésimos de segundos 22.   } 23.   // Avança de 90 graus até 180 graus 24.   for (i = 0; i <= 90; i += 1) { 25.     servo_11.write(i); 26.     delay(30); // Aguarda 30 milésimos de segundos 27.   } 28.   delay(1000); // Aguarda 1 segundo 29.   // Avança de 180 graus até 90 graus 30.   for (i = 180; i >= 90; i -= 1) { 31.     servo_11.write(i); 32.     delay(30); // Aguarda 30 milésimos de segundos 33.   } 34.   // Avança de 90 graus até 0 graus 35.   for (i = 180; i >= 0; i -= 1) { 36.     servo_11.write(i); 37.     delay(15); // Aguarda 15 milésimos de segundos 38.   } 39. } 

EX 8)
40. // Biblioteca para manipular o servo 41. #include <Servo.h> 42.  43. //Armazena o estado do botão lido 44. int estadoBotao = 0; 45.  46. //Guarda o estado 47. int guardaEstado = 0; 48.  49. // Variável do micro servo 50. Servo servo_11; 51.  52. void setup() 53. {  54.   // Porta 12 (Botão) em modo de entrada(leitura). 55.   pinMode(12, INPUT); 56.   // Conecta o micro servo na porta 11 57.   servo_11.attach(11, 500, 2500); 58. } 59.  60. void loop() 61. { 62.   // Leitura do estado do botão 63.   estadoBotao = digitalRead(12); 64.   // Avalia o estado lido 65.   if (estadoBotao == HIGH) { 66.     // Troca o estado guardado 67.     if (guardaEstado == HIGH) { 68.       guardaEstado = LOW; 69.     } else { 70.       guardaEstado = HIGH; 71.     } 72.   } 73.   //Se estado guardado é ligado 74.   if (guardaEstado == HIGH) { 75.     // Avança até 180 graus 76.     servo_11.write(180); 77.   } else { 78.     // Avança até 0 graus 79.     servo_11.write(0); 80.   } 81.   delay(25); // Aguarda 250 milésimos de segundos 82. } 

EX 9)
1. void setup() 2. { 3.   // Porta 12 (LED_BUILTIN) em modo de saída(escrita). 4.   pinMode(12, OUTPUT); 5. } 6.  7. void loop() 8. { 9.   tone(12, 294, 1000); // play tone 50 (D4 = 294 Hz) 10.   delay(1000); // Atrase por 1000 milissegundos 11.   tone(12, 311, 1000); // play tone 51 (D#4 = 311 Hz) 12.   delay(1000); // Atrase por 1000 milissegundos 13.   tone(12, 330, 1000); // play tone 52 (E4 = 330 Hz) 14.   delay(1000); // Atrase por 1000 milissegundos 15.   tone(12, 349, 1000); // play tone 53 (F4 = 349 Hz) 16.   delay(1000); // Atrase por 1000 milissegundos 17.   tone(12, 370, 1000); // play tone 54 (F#4 = 370 Hz) 18.   delay(1000); // Atrase por 1000 milissegundos 19.   tone(12, 392, 1000); // play tone 55 (G4 = 392 Hz) 20.   delay(1000); // Atrase por 1000 milissegundos 21.   tone(12, 415, 1000); // play tone 56 (G#4 = 415 Hz) 22.   delay(1000); // Atrase por 1000 milissegundos 23. } 

EX 10)
24. void setup() 25. { 26.    27. } 28.  29. void loop() 30. { 31.    32.   delay(10); // Atrase por 1000 milissegundos 33. } 
